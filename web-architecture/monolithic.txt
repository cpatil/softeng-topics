In software engineering, a monolithic application describes a single-tiered
software application in which the user interface and data access code are
combined into a single program from a single platform.

A monolithic application is self-contained and independent from other computing
applications. The design philosophy is that the application is responsible not
just for a particular task, but can perform every step needed to complete a
particular function. Today, some personal finance applications are monolithic in
the sense that they help the user carry out a complete task, end to end, and are
private data silos rather than parts of a larger system of applications that
work together. Some word processors are monolithic applications. These
applications are sometimes associated with mainframe computers.

In software engineering, a monolithic application describes a software
application that is designed without modularity.Modularity is desirable, in
general, as it supports reuse of parts of the application logic and also
facilitates maintenance by allowing repair or replacement of parts of the
application without requiring wholesale replacement.

Modularity is achieved to various extents by different modularization
approaches. Code-based modularity allows developers to reuse and repair parts of
the application, but development tools are required to perform these maintenance
functions (e.g. the application may need to be recompiled). Object-based
modularity provides the application as a collection of separate executable files
that may be independently maintained and replaced without redeploying the entire
application (e.g. Microsoft "dll" files; Sun/UNIX "shared object" files. Some
object messaging capabilities allow object-based applications to be distributed
across multiple computers (e.g. Microsoft COM+). Service-oriented architectures
use specific communication standards/protocols to communicate between modules.

In its original use, the term "monolithic" described enormous mainframe
applications with no usable modularity.This, in combination with the rapid
increase in computational power and therefore rapid increase in the complexity
of the problems which could be tackled by software, resulted in unmaintainable
systems and the "software crisis". 